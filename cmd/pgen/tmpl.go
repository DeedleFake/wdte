package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"text/template"
)

var tmpl = template.New("code")

func init() {
	token := func(t Token) string {
		switch t := t.(type) {
		case Term:
			return fmt.Sprintf("Term{Type: %q, Keyword: %q}", t.Type, t.Keyword)

		case NTerm:
			return fmt.Sprintf("NTerm(%q)", t[1:len(t)-1])

		case Epsilon:
			return "Epsilon{}"
		}

		panic(fmt.Errorf("Unexpected token type: %T", t))
	}

	tmpl.Funcs(template.FuncMap{
		"token": token,
		"rule": func(r Rule) string {
			var buf bytes.Buffer
			buf.WriteString("Rule{")

			var s string
			for _, t := range r {
				buf.WriteString(s)
				buf.WriteString(token(t))
				s = ", "
			}

			buf.WriteRune('}')
			return buf.String()
		},
	})

	tmpl = template.Must(tmpl.Parse(`// This file was auto-generated by pgen.
// Editing is not advised.

package pgen

type Lookup struct {
	Term Term
	NTerm NTerm
}

type Token interface{}

type Term struct {
	Type string
	Keyword string
}

type NTerm string

type Epsilon struct{}

var Table = map[Lookup]Rule{
	{{ range $nterm, $_ := . }}
		{{- range $term, $from := $.First $nterm -}}
			{Term: {{ $term | token }}, NTerm: {{ $nterm | token -}} }: {{ $from | rule }},
		{{ end -}}
	{{ end }}
}`))
}

type formatter struct {
	w   io.Writer
	buf bytes.Buffer
}

func (f *formatter) Write(data []byte) (int, error) {
	return f.buf.Write(data)
}

func (f formatter) Close() error {
	src, err := format.Source(f.buf.Bytes())
	if err != nil {
		return err
	}

	_, err = f.w.Write(src)
	return err
}
